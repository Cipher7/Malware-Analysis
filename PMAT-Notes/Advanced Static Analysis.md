# Advanced Static Analysis

## Introduction 

Advanced Static Analysis involves in-depth analysis at code level and the functions and processes invoked and also the understandind the execution flow of the program by analyzing the disassembled code.

Types of tools used :
- Decompilers

The code after decompiling is in assembly which is closest to the machine code, this code is raw and will require some practice and familiarity to understand.


## Disassembling and Decompiling a Malware Dropper

__Binary used__ : _Dropper.DownloadFromURL.exe.malz_

![Pasted image 20220913165438](PMAT-Attachments/Pasted%20image%2020220913165438.png)

> Program used : _Cutter_

![Pasted image 20220913165623](PMAT-Attachments/Pasted%20image%2020220913165623.png)

Select the file and load it in :

![Pasted image 20220913165758](PMAT-Attachments/Pasted%20image%2020220913165758.png)


Navigate to the main function :

![Pasted image 20220913165907](PMAT-Attachments/Pasted%20image%2020220913165907.png)

We can see some familiar strings from basic static analysis.

Open the graph function :

![Pasted image 20220913170022](PMAT-Attachments/Pasted%20image%2020220913170022.png)


Open the Decompiler tab :

![Pasted image 20220913170235](PMAT-Attachments/Pasted%20image%2020220913170235.png)

We can see that _Cutter_ has tried to convert the assembly back to C and has tried to make it look as close as possible to the original source code.

We can also see the Windows API calls being made along with their input and also the clear text commands being run.


## x86 CPU Architecture

Links to materials which can give you an in-depth knowlegde of x86 based CPU architecture.

- https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture
- https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
- https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming
- https://courses.cs.washington.edu/courses/cse351/10sp/lectures/05-isa.pdf
- https://resources.infosecinstitute.com/topic/x86-basics-data-representation-memory-and-information-storage/


## Advanced Analysis of Process Injector

__Binary Used__ : _Malware.stage0.exe_

![Pasted image 20220913190927](PMAT-Attachments/Pasted%20image%2020220913190927.png)


### Signatures

Writes an executable in the _C:\\Users\\Public_ folder

![Pasted image 20220913190319](PMAT-Attachments/Pasted%20image%2020220913190319.png)

Opens a port on the localhost 

![Pasted image 20220913190442](PMAT-Attachments/Pasted%20image%2020220913190442.png)

The binary which runs is not the same as the one which is written to the Public directory.

Gives a shell when a listener is setup on the same port.

![Pasted image 20220913190546](PMAT-Attachments/Pasted%20image%2020220913190546.png)


### Running Cutter on the newly written binary

__Binary name__ : _werflt.exe_

Open the main function in graph view

![Pasted image 20220913191415](PMAT-Attachments/Pasted%20image%2020220913191415.png)
![Pasted image 20220913191432](PMAT-Attachments/Pasted%20image%2020220913191432.png)

Instruction Process in the above assembly code :
- First we see a lpBuffer being initialized along with a few other variables.
- The base pointer and the stack pointers are initialized before loading the stack.
- Moving down the the _OpenProcess_ windows API call, we observer the 3 variables being loaded and use in the API call. 
- Next we see a _VirtualAlloc_ API call being made, this allocates memory with memory commit and memory reset as the push of ___0x3000___ is made a few lines above.
![Pasted image 20220913192356](PMAT-Attachments/Pasted%20image%2020220913192356.png)

- Also the flProtect is pushed with RWX permissions, this we know as a push of 0x40 is made in the stack.
![Pasted image 20220913192444](PMAT-Attachments/Pasted%20image%2020220913192444.png)

- Next the buffer from _lpBuffer_ would be written to this newly created space using the _WriteProcessMemory_ Windows API
- Lastly, a _CreateRemoteThread_ would be called with the instruction pointer set to the start of this buffer and a seperate thread would be created which spawns the reverse shell.

### Process Hacker 2

![Pasted image 20220913192844](PMAT-Attachments/Pasted%20image%2020220913192844.png)

Opening the _WerFault.exe_ and analyzing memory.

![Pasted image 20220913193013](PMAT-Attachments/Pasted%20image%2020220913193013.png)

We can see the shellcode that has been written.

![Pasted image 20220913193036](PMAT-Attachments/Pasted%20image%2020220913193036.png)

### Resources

- https://docs.microsoft.com/en-us/windows/win32/Memory/memory-protection-constants
- https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex